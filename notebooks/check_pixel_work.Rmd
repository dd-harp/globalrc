---
title: "Global Rc"
output: html_notebook
---

# Introduction

This checks the pixel_work function visually.

## Goals

```{r load_libraries}
library(dplyr)
library(futile.logger)
library(plotrix)
library(pracma)  # "practical math" alternative interpolation.
library(rprojroot)
library(viridis)
library(globalrc)
library(rampdata)
invisible(flog.threshold(INFO))  # Set to DEBUG if you want to see messages.
proj_root <- rprojroot::find_root(rprojroot::is_git_root)
config <- file.path(proj_root, "scripts", "rc_kappa.toml")
rampdata::initialize_workflow(config)
```

```{r plot_set_up}
make_colors <- function() {
  col <- viridis::plasma(7, alpha = 1, begin = 0, end = 1)
  c(pfpr = col[1], am = col[2], alpha = col[3], kappa = col[4], aeir = col[5],
       vc = col[6], rc = col[7])
}
mcol <- make_colors()
var_names <- c("alpha", "kappa", "aeir", "vc", "rc")
var_colors <- mcol[var_names]
```

## Initialization

Austin made a map from PR and rho to AR. We will use that function,
so load the data he calculated, and create an interpolation function.
```{r read_script}

# Load the data that Austin made, turning it into a function.
local_pr2ar <- as.path(workflow_path("pr2ar"))
if (!file.exists(local_pr2ar)) {
  local_pr2ar <- file.path("..", local_pr2ar)
  flog.debug("looking for pr2ar up a directory", local_pr2ar)
}
pr_to_ar_dt <- data.table::fread(local_pr2ar)
params <- configr::read.config(config)$parameters
show_df <- data.frame(params)
strategies <- list(
  pr_to_ar = ar_of_pr_rho(pr_to_ar_dt),
  ar2pr = globalrc::build_ar2pr(pr_to_ar_dt)
)
show_df
```

## The main function

```{r}
# Lets me make a copy of parameters with some changes.
set_params <- function(p, ...) {
  ll <- list(...)
  p[names(ll)] <- ll
  p
}
params2 <- set_params(params, kam = 0.6)
data.frame(params2[vapply(params2, is.numeric, logical(1))])
```

Make a table of values with the draws. That means we set the two inputs,
pfpr and rho. Then we generate draws of parameter values, run the function
against the inputs and parameter values, and summarize the results with
mean and quantiles.
```{r table_with_draws}
pfpr <- seq(0.02, 0.98, 0.02)
rho <- seq(0, 0.5, 0.1)
df <- data.frame(list(pfpr = rep(pfpr, length(rho)), rho = rep(rho, each = length(pfpr))))
df$am <- df$rho / params$kam
sample_cnt <- nrow(df)
draw_cnt <- 1000
draw_params <- draw_parameters(params2, draw_cnt)

over_draws <- lapply(1:draw_cnt, function(draw_idx) {
  pixel_three(df$pfpr, df$am, draw_params[draw_idx, ], strategies)
})
var_names <- names(over_draws[[1]])
for (single_var in "rc") {
  single_arr <- vapply(over_draws, function(one_draw) {
    one_draw[[single_var]]
  }, FUN.VALUE = numeric(sample_cnt))
  dim(single_arr)
  single_summary <- list(
    mean = apply(single_arr, c(1), mean),
    median = apply(single_arr, c(1), function(x) quantile(x, 0.5)),
    lower = apply(single_arr, c(1), function(x) quantile(x, 0.025)),
    upper = apply(single_arr, c(1), function(x) quantile(x, 0.975)),
    max = apply(single_arr, c(1), max),
    min = apply(single_arr, c(1), min)
  )
  names(single_summary) <- sprintf("%s_%s", single_var, names(single_summary))
  df <- cbind(df, single_summary)
}
data.table::fwrite(df, file = file.path(proj_root, "notebooks", "pixel_three.csv"))
df
```



How about making a table of values.
```{r create_table_of_values}
pfpr <- c(0.01, 0.1, 0.2, 0.3, 0.4, 0.8)
am <- c(0.00, 0.02, 0.3, 0.6)
df <- data.frame(list(pfpr = rep(pfpr, length(am)), am = rep(am, each = length(pfpr))))
res <- vapply(
  1:nrow(df),
  function(row) {
    ll <- pixel_two(df$pfpr[row], df$am[row], params, strategies)
    setNames(as.numeric(ll), names(ll))
    },
  FUN.VALUE = numeric(8)
  )
cbind(df, t(res))
```


```{r inset_rc, eval = FALSE}
inset_rc <- function(pfpr, rc) {
  u <- par("usr")
  v <- c(
    grconvertX(u[1:2], "user", "ndc"),
    grconvertY(u[3:4], "user", "ndc")
  )
  v <- c( (v[1]+v[2])/2, v[2], (v[3]+v[4])/2, v[4] )
  par( fig=v, new=TRUE, mar=c(0,0,0,0) )
  plot(pfpr, rc, axes=TRUE, xlab="", ylab="")
  box()
}
```

Plot annual EIR (i.e. multiply daily EIR by 365) vs PR, and plot on a log10 scale.
```{r annual_eir, fig.height = 5, fig.width = 10}
pfpr <- seq(0.01, 0.99, 0.01)
par(mfrow = c(2, 2))
for (am0 in c(0.0, 0.01, 0.1, 0.3)) {
am <- rep(am0, length(pfpr))
k_is_one <- function(p) {
  p$kam <- 1.0
  p
  }
vars <- pixel_two(pfpr, am, k_is_one(params), strategies)
plot(
  vars$aeir, pfpr,
  main = sprintf("rho = %3.2f", am0), xlab = "EIR [annual log10]", ylab = "PfPR",
  log = "x", type = "l", col = var_colors["aeir"]
)
}
```

```{r annual_eir_shift, fig.height = 5, fig.width = 7}
pfpr <- seq(0.01, 0.99, 0.01)
k_is_one <- function(p) {
  p$kam <- 1.0
  p
  }
#par(mfrow = c(1, 2))
amcol <- viridis::plasma(7, alpha = 1, begin = 0, end = 1)
am0 <- 0.0
am <- rep(am0, length(pfpr))
plot(
  numeric(0), numeric(0),
  xlim = c(1e-2, 1e10), ylim = c(0, 1),
  main = sprintf("Comparing across rho values for whole model", am0),
  xlab = "PfEIR [annual log10]", ylab = "PfPR",
  log = "x", type = "l"
)
amchoices <- seq(0, .6, 0.1)
for (am_idx in seq_along(amchoices)) {
  am0 <- amchoices[am_idx]
am <- rep(am0, length(pfpr))
vars <- pixel_two(pfpr, am, k_is_one(params), strategies)
lines(
  vars$aeir, pfpr,
  col = amcol[am_idx]
)
}
legend(
  "bottomright", legend = as.character(amchoices), title = "rho",
  col = amcol[1:length(amchoices)], lty = 1, lwd = 2, cex = 1)
```
```{r variable_by_variable, fig.height = 10, fig.width = 20}
cnt <- 200
pfpr <- 1:cnt/(cnt + 1)
run_one <- function(am) pixel_two(pfpr, rep(am, length(pfpr)), params, strategies)
var_names <- names(run_one(0.1))

flip <- TRUE
par(mfrow = c(2,4))
am_choices <- rev(seq(0, 0.6, 0.1))
vbv_col <- rev(viridis::plasma(length(am_choices), alpha = 1, begin = 0, end = 1))
for (var_name in var_names) {
  for (am_idx in seq_along(am_choices)) {
    am0 <- am_choices[am_idx]
    res <- run_one(am0)
    vary <- res[[var_name]]
    if (flip) {
      y <- pfpr
      x <- vary
      logv <- "x"
      xlab <- var_name
      ylab <- "PfPR"
    } else {
      x <- pfpr
      y <- vary
      logv <- "y"
      xlab <- "PfPR"
      ylab <- var_name
    }
    if (am_idx == 1) {
      plot(
        x, y,
        log = logv, xlab = xlab,
        ylab = ylab, col = vbv_col[am_idx], type = "l")
    } else {
      lines(x, y, type = "l", col = vbv_col[am_idx])
    }
  }
  legend("topleft", legend = sprintf("AM=%3.2f", am_choices), col = vbv_col, lty = 1, lwd = 2, cex = 1)
}
```
```{r}
alpha <- seq(0.01, 0.99, 0.01)
h <- -log(1 - alpha)
plot(alpha, h)
```


Let's try a range of PfPR for one AM.
```{r plot_pfpr_for_an_am, fig.height = 20, fig.width = 10}
cnt <- 200

par(mfrow = c(3,1))
for (am0 in c(0.0, 0.1, 0.5)) {
  pfpr <- 1:cnt/(cnt + 1)
  am <- rep(am0, length(pfpr))
  res <- pixel_two(pfpr, am, params, strategies)
  name <- "alpha"
  plot(
    pfpr, res[[name]],
    xlim = c(0, 1), ylim = c(1e-3, 1e3), log = "y", xlab = "PfPR",
    main = sprintf("AM=%3.2f", am0), ylab = "", col = mcol[name], type = "l")
  not_alpha <- names(res)[!names(res) %in% name]
  for (name in not_alpha) {
    lines(pfpr, res[[name]], type = "l", main = name, ylab = "", col = mcol[name])
  }
  legend("topleft", legend = var_names, col = var_colors, lty = 1, lwd = 2, cex = 1)
}
```
## Testing

```{r test_ar_to_pr_interpolation}
library(testthat)
test_that("rho faster matches", {
  # Using different bounds means we can check that x and y aren't switched.
  rho_grid <- pracma::linspace(-1, 1, 11)
  pr_grid <- pracma::linspace(0, 1, 20)
  testf <- function(x, y) { sin(x) + 2 * cos(y) }
  rho_in <- rep(rho_grid, length(pr_grid))
  pr_in <- rep(pr_grid, each = length(rho_grid))
  zi <- testf(rho_in, pr_in)
  trialf <- ar_of_pr_rho(data.frame(list(rho = rho_in, PR = pr_in, AR = zi)))
  rhot <- c(-0.5, 0.9, -0.1)
  prt <- c(0.9, 0.8, 0.1)
  zt <- trialf(rhot, prt)
  expect_equal(length(zt), length(rhot))
  zpred <- testf(rhot, prt)
  expect_lt(max(abs(zt - zpred)), 0.01)
})
test_that("pr faster matches", {
  # The loop says that as grid gets finer answer gets closer.
  max_miss <- 0.01
  for (i in 0:3) {
    rho_grid <- pracma::linspace(-1, 1, 11 * 2^i)
    pr_grid <- pracma::linspace(0, 1, 20 * 2^i)
    testf <- function(x, y) { sin(x) + 2 * cos(y) }
    pr_in <- rep(pr_grid, length(rho_grid))
    rho_in <- rep(rho_grid, each = length(pr_grid))
    zi <- testf(rho_in, pr_in)
    trialf <- ar_of_pr_rho(data.frame(list(rho = rho_in, PR = pr_in, AR = zi)))
    rhot <- c(-0.5, 0.9, -0.1)
    prt <- c(0.9, 0.8, 0.1)
    zt <- trialf(rhot, prt)
    expect_equal(length(zt), length(rhot))
    zpred <- testf(rhot, prt)
    this_miss <- max(abs(zt - zpred))
    # Ask that convergence be better than linear.
    expect_lt(this_miss, max_miss / 2)
    max_miss <- this_miss
    flog.debug(this_miss)
  }
})
```

